<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pluto</title>
  <subtitle>One demo website</subtitle>
  <link href="https://lzwpluto.github.io/" rel="alternate" type="text/html"/>
  <link href="https://lzwpluto.github.io/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://lzwpluto.github.io/</id>
  <updated>2026-01-19T14:10:30.710Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>张量的基本运算</title>
    <link href="https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-01-19T00:00:00.000Z</updated>
    <summary>张量的基本运算</summary>
    <content type="html"><![CDATA[<h1>day02.02_张量的基本运算</h1>
<h2>Docstring</h2>
<blockquote>
<p>案例：
演示张量的基本运算操作，包括加法、减法、乘法和除法。</p>
<p>涉及到的API：
add(), sub(), mul(), div(), neg() --&gt; 张量的加法、减法、乘法、除法和取负操作
add_(), sub_(), mul_(), div_() --&gt; 张量的加法、减法、乘法、除法的原地操作(可以修改源数据, 类似于C语言中++c和c++的区别)</p>
<p>掌握：
+, -, *, /</p>
<p>掌握：
1.可以用+、-、*、/进行张量的基本运算
2.如果是张量和数值运算，则：张量的每个元素都和该数值进行运算</p>
</blockquote>
<pre><code># 导包
import torch

# 1.创建张量
t1 = torch.tensor([1, 2, 3])

# 2.张量的加法
# t2 = t1.add(10) # 不会修改源数据
# t2 = t1 + 10  # 不会修改源数据
# t1.add_(10) # 会修改源数据
#t1 += 10 # 会修改源数据


# 其他运算类似
# t2 = t1.sub(1)
# t2 = t1.mul(2)
# t2 = t1.div(2)  # 有小数
# t2 = t1.neg()  # 取负数
t2 = t1 // 2
# 3.打印结果
print(f't1:{t1}')
print(f't2:{t2}')
</code></pre>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="技术"></category>
  </entry>
  <entry>
    <title>张量类型转换</title>
    <link href="https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-01-19T00:00:00.000Z</updated>
    <summary>张量类型转换</summary>
    <content type="html"><![CDATA[<h1>04_张量类型转换</h1>
<h2>Docstring</h2>
<blockquote>
<p>案例：
创建指定类型的张量</p>
<p>涉及到的函数如下：
torch.type （torch支持的数据类型）
torch.half, torch.float, torch.double, torch.short, torch.int, torch.long</p>
<p>需要掌握的函数：
torch.type</p>
</blockquote>
<pre><code># 导包
import torch

# 场景1: 直接创建指定类型的张量
t1 = torch.tensor(data=[1, 2, 3, 4, 5], dtype=torch.float) # 默认是torch.float32
print(f't1: {t1}, (元素)type: {t1.dtype}, (张量)type: {type(t1)}')
print('-' * 30)

# 场景2: 创建好张量后，进行类型转换
# 思路1：使用.type()方法
t2 = t1.type(torch.int16)
print(f't2: {t2}, (元素)type: {t2.dtype}, (张量)type: {type(t2)}')
print('-' * 30)

# 思路2：使用专用的转换函数
print(t2.half()) # 转换为float16
print(t2.float()) # 转换为float32
print(t2.double()) # 转换为float64
print(t2.short()) # 转换为int16
print(t2.int()) # 转换为int32
print(t2.long()) # 转换为int64
print('-' * 30)
</code></pre>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="技术"></category>
  </entry>
  <entry>
    <title>创建全0全1指定值张量</title>
    <link href="https://lzwpluto.github.io/posts/%E5%88%9B%E5%BB%BA%E5%85%A80%E5%85%A81%E6%8C%87%E5%AE%9A%E5%80%BC%E5%BC%A0%E9%87%8F/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E5%88%9B%E5%BB%BA%E5%85%A80%E5%85%A81%E6%8C%87%E5%AE%9A%E5%80%BC%E5%BC%A0%E9%87%8F/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-01-19T00:00:00.000Z</updated>
    <summary>创建全0全1指定值张量</summary>
    <content type="html"><![CDATA[<h1>03_创建全0全1指定值张量</h1>
<h2>Docstring</h2>
<blockquote>
<p>案例：
演示如何创建全0张量、全1张量以及指定值张量。</p>
<p>涉及到的函数如下：
torch.ones 和 torch.ones_like - 创建全1张量
torch.zeros 和 torch.zeros_like - 创建全0张量
torch.full 和 torch.full_like - 创建指定值张量</p>
<p>需要掌握的函数：
torch.zeros, torch.full</p>
</blockquote>
<pre><code># 导包
import torch

# 场景1: torch.ones 和 torch.ones_like 创建全1张量
t1 = torch.ones(2, 3)
print(f't1: {t1}, type: {type(t1)}')
print('-' * 30)
t2 = torch.tensor([[1, 2], [3, 4], [5, 6]])
print(f't2: {t2}, type: {type(t2)}')
print('-' * 30)
# t3 --&gt; 基于t2创建一个全1张量
t3 = torch.ones_like(t2)
print(f't3: {t3}, type: {type(t3)}')
print('-' * 30)

# 场景2: torch.zeros 和 torch.zeros_like 创建全0张量
t4 = torch.zeros(2, 4)
print(f't4: {t4}, type: {type(t4)}')
print('-' * 30)
t5 = torch.tensor([[7, 8, 9], [10, 11, 12]])
print(f't5: {t5}, type: {type(t5)}')
print('-' * 30)
# t6 --&gt; 基于t5创建一个全0张量
t6 = torch.zeros_like(t5)
print(f't6: {t6}, type: {type(t6)}')
print('-' * 30)

# 场景3: torch.full 和 torch.full_like 创建指定值张量
t4 = torch.full(size=(2,3), fill_value=255) # 创建一个2行3列，值为255的张量
print(f't4: {t4}, type: {type(t4)}')
print('-' * 30)

t5 = torch.tensor([[7, 8, 9], [10, 11, 12]])
print(f't5: {t5}, type: {type(t5)}')
print('-' * 30)
# t6 --&gt; 基于t5创建一个全0张量
t6 = torch.full_like(t5, fill_value=255)
print(f't6: {t6}, type: {type(t6)}')
print('-' * 30)
# 函数测试
</code></pre>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="技术"></category>
  </entry>
  <entry>
    <title>创建线性和随机张量</title>
    <link href="https://lzwpluto.github.io/posts/%E5%88%9B%E5%BB%BA%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9A%8F%E6%9C%BA%E5%BC%A0%E9%87%8F/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E5%88%9B%E5%BB%BA%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9A%8F%E6%9C%BA%E5%BC%A0%E9%87%8F/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-01-19T00:00:00.000Z</updated>
    <summary>创建线性和随机张量</summary>
    <content type="html"><![CDATA[<h1>02_创建线性和随机张量</h1>
<h2>Docstring</h2>
<blockquote>
<p>案例：演示创建线性张量和随机张量的方式</p>
<p>涉及到的函数：
torch.arange 和 torch.linspace 创建线性张量
torch.random.initial_seed 和 torch.random.manual_seed 设置随机种子
torch.rand/randn 创建随机浮点类型张量
torch.randint(low, high, size=()) 创建随机整数类型张量</p>
<p>要掌握的函数：
torch.arrange
torch.linspace
torch.manual_seed
torch.randint</p>
</blockquote>
<pre><code># 导包
import torch

# 1.定义函数，演示：torch.arange 和 torch.linspace 创建线性张量
def dm01():
    # 场景1：创建指定范围的线性张量
    # 参1：起始值，参2：终止值（不包含），参3：步长
    t1 = torch.arange(0,10,2)
    print(f't1: {t1}, type: {type(t1)}')
    print('-'*30)

    # 场景2：创建指定范围和指定个数的线性等差数列
    # 参1：起始值，参2：终止值（包含），参3：元素个数
    t2 = torch.linspace(1,10,4)
    print(f't2: {t2}, type: {type(t2)}')


# 2.定义函数，演示：torch.random.initial_seed 和 torch.random.manual_seed 设置随机种子
def dm02():
    # step1：设置随机种子
    #torch.initial_seed()        # 默认使用系统时间戳作为随机种子
    torch.manual_seed(3)      # 设置随机种子


    # step2：创建随机张量
    # 场景1：均匀分布的（0，1）随机张量
    t1 = torch.rand(2,3)
    print(f't1: {t1}, type: {type(t1)}')
    print('-'*30)

    # 场景2：正态分布的随机张量
    t2 = torch.randn(2,3)
    print(f't2: {t2}, type: {type(t2)}')
    print('-'*30)

    # 场景3：创建随机整数张量
    t3 = torch.randint(1,10,size=(3,5))
    print(f't3: {t3}, type: {type(t3)}')


# 3.测试函数
if __name__ == "__main__":
    # dm01()
    dm02()
</code></pre>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="技术"></category>
  </entry>
  <entry>
    <title>张量的点乘和矩阵乘法</title>
    <link href="https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E7%82%B9%E4%B9%98%E5%92%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E7%82%B9%E4%B9%98%E5%92%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-01-19T00:00:00.000Z</updated>
    <summary>张量的点乘和矩阵乘法</summary>
    <content type="html"><![CDATA[<h1>day02.03_张量的点乘和矩阵乘法</h1>
<h2>Docstring</h2>
<blockquote>
<p>案例：
演示张量的点乘和矩阵乘法操作。
点乘：
要求：两个张量的维度必须相同，对应位置的元素直接做相应的操作
API：
t1 * t2
t1.mul(t2)  #nultiply: 点乘
矩阵乘法：
要求：两个张量，第一个张量的列数，等于第二个张量的行数（A列=B行）
结果：A行B列
API：
t1 @ t2
t1.matmul(t2)  # matrix multiply: 矩阵乘法
t1.dot(t2)     # 扩展：只针对于一维张量有效</p>
</blockquote>
<pre><code># 导包
import torch

# 1.定义函数，演示张量：点乘
def dm01():
    # 1.定义张量，2行3列
    t1 = torch.tensor([[1, 2, 3],[4, 5, 6]])
    print(f't1: {t1}')

    # 2.定义张量，2行3列
    t2 = torch.tensor([[1, 2, 3],[4, 5, 6]])
    print(f't2: {t2}')

    # 3.点乘
    # t3 = t1 * t2
    t3 = t1.mul(t2) #效果同上
    # 4.打印结果
    print(f't3: {t3}')

# 2.定义函数，演示张量：矩阵乘法
def dm02():
    # 条件：A列 = B行，结果：A行B列
    # 1.定义张量，2行3列
    t1 = torch.tensor([[1, 2, 3],[4, 5, 6]])
    print(f't1: {t1}')

    # 2.定义张量，2行3列
    t2 = torch.tensor([[7, 8],[9, 10],[11, 12]])
    print(f't2: {t2}')

    # 3.矩阵乘法
    t3 = t1 @ t2
    # t3 = t1.matmul(t2) #效果同上,matrix multiply(矩阵乘法)

    # 4.打印结果
    print(f't3: {t3}')

    # 5.演示dot()函数
    # t3 = t1.dot(t2) # 报错
    t4 = torch.tensor([1, 2, 3])
    t5 = torch.tensor([4, 5, 6])
    t6 = t4.dot(t5)
    print(f't6: {t6}')

# 3.调用函数，测试
if __name__ == '__main__':
    dm01()
    dm02()
</code></pre>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="技术"></category>
  </entry>
  <entry>
    <title>张量和numpy之间相互转换</title>
    <link href="https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E5%92%8Cnumpy%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E5%92%8Cnumpy%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-01-19T00:00:00.000Z</updated>
    <summary>张量和numpy之间相互转换</summary>
    <content type="html"><![CDATA[<h1>day02.01_张量和numpy之间相互转换</h1>
<h2>Docstring</h2>
<blockquote>
<p>案例：
演示如何在PyTorch张量和NumPy数组之间进行相互转换，以及如何从标量中提取其内容</p>
<p>涉及到的API：
场景1：张量 --&gt; numpy nd数组对象
张量对象.numpy()         共享内存
张量对象.numpy().copy()  不共享内存, 链式编程写法,
场景2：numpy nd数组对象 --&gt; 张量
from_numpy()             共享内存
torch.tensor(nd数组)     不共享内存
场景3：从标量张量中提取其内容
标量张量.item()</p>
<p>掌握：
张量 --&gt; numpy： 张量对象.numpy()
numpy --&gt; 张量： torch.tensor(nd数组)
从标量张量中提取其内容： 标量张量.item()</p>
</blockquote>
<pre><code># 导包
import torch
import numpy as np

# 1. 定义函数，演示：张量 --&gt; numpy
def dm01():
    # 1. 创建一个张量
    t1 = torch.tensor([1,2,3,4,5])
    print(f't1: {t1}, type: {type(t1)}')
    # 2. 张量 --&gt; numpy
    # n1 = t1.numpy() # 共享内存
    n1 = t1.numpy().copy() # 不共享内存
    print(f'n1: {n1}, type: {type(n1)}')
    # 3. 修改n1中的数据，观察t1的变化
    n1[0] = 100
    print(f'n1: {n1}')
    print(f't1: {t1}')
    print('-' * 30)

# 2. 定义函数，演示：numpy --&gt; 张量
def dm02():
    # 1. 创建一个numpy nd数组对象
    n1 = np.array([10,20,30])
    print(f'n1: {n1}, type: {type(n1)}')
    # 2. numpy --&gt; 张量
    # t1 = torch.from_numpy(n1).type(torch.float32) # 转换+转类型
    t1 = torch.from_numpy(n1) # 共享内存
    print(f't1: {t1}, type: {type(t1)}')

    t2 = torch.tensor(n1) # 不共享内存
    print(f't2: {t2}, type: {type(t2)}')

    # 3. 修改n1中的数据，观察t1和t2的变化
    n1[0] = 200
    print(f'n1: {n1}')
    print(f't1: {t1}')
    print(f't2: {t2}')
    print('-' * 30)

# 3. 定义函数，演示：从标量张量(只有一个值的张量)中提取其内容
def dm03():
    # 1.创建张量
    t1 = torch.tensor(100)          # 标量张量，可以
    # t1 = torch.tensor([100, ])      # 可以
    # t1 = torch.tensor([100, 200])   # 注意：这里不是标量张量
    print(f't1: {t1}, type: {type(t1)}')
    # 2.提取标量张量中的内容
    a = t1.item()
    print(f'value: {a}, type: {type(a)}')

# 4. 测试
if __name__ == '__main__':
    #dm01()
    #dm02()
    dm03()
</code></pre>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="技术"></category>
  </entry>
  <entry>
    <title>张量的基本创建方式</title>
    <link href="https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-01-19T00:00:00.000Z</updated>
    <summary>张量的基本创建方式</summary>
    <content type="html"><![CDATA[<h1>01_张量的基本创建方式</h1>
<h2>Docstring</h2>
<blockquote>
<p>案例：演示张量的基本创建方式</p>
<p>张量：
Pytorch框架属于最常用的深度学习框架之一，无论是后续要学的ANN（人工神经网络）、CNN（卷积神经网络）、RNN（循环神经网络）等模型，都离不开张量的操作。
张量（Tensor）是Pytorch中最基本</p>
<pre><code>张量 -&gt; 存储同一类元素的容器，且元素值必须是数值才可以
</code></pre>
<p>张良的基本创建方式：
torch.tensor 根据指定的数据创建
torch.Tensor 根据形状创建张量，其他可用来创建指定的张量
torch.IntTensor、 torch.FloatTensor、torch.DoubleTensor 根据指定的数据类型创建张量</p>
<p>细节：
Tensor方式较之于tensor方式，可以直接创建指定形状的张量</p>
</blockquote>
<pre><code># 导包
import torch
import numpy as np

# 1.定义函数，演示：torch.tensor 根据指定的数据创建

def dm01():
    # 场景1：标量 张量
    t1 = torch.tensor(10)
    print(f't1: {t1}, type: {type(t1)}')
    print('-'*30)

    # 场景2：列表 --&gt; 张量
    data = [[1,2,3],[4,5,6]]
    t2 = torch.tensor(data)
    print(f't2: {t2}, type: {type(t2)}')
    print('-'*30)

    # 场景3：numpy nd数组 --&gt; 张量
    data = np.random.randint(1,10,size=(2,3))
    t3 = torch.tensor(data, dtype=torch.float32)
    print(f't3: {t3}, type: {type(t3)}')
    print('-'*30)

    # 场景4：尝试直接创建 指定维度（例如2行3列的）张量
    # t4 = torch.tensor(data=2, dtype=3)
    # print(f't4: {t4}, type: {type(t4)}')

# 2.定义函数，演示：根据形状创建张量，其他可用来创建指定的张量
def dm02():
    # 场景1：标量 张量
    t1 = torch.Tensor(10)
    print(f't1: {t1}, type: {type(t1)}')
    print('-'*30)

    # 场景2：列表 --&gt; 张量
    data = [[1,2,3],[4,5,6]]
    t2 = torch.Tensor(data)
    print(f't2: {t2}, type: {type(t2)}')
    print('-'*30)

    # 场景3：numpy nd数组 --&gt; 张量
    data = np.random.randint(1,10,size=(2,3))
    t3 = torch.Tensor(data)
    print(f't3: {t3}, type: {type(t3)}')
    print('-'*30)

    # 场景4：尝试直接创建 指定维度（例如2行3列的）张量
    t4 = torch.Tensor(2, 3)
    print(f't4: {t4}, type: {type(t4)}')

# 3.定义函数，演示：torch.IntTensor、 torch.FloatTensor、torch.DoubleTensor 根据指定的数据类型创建张量
def dm03():
    # 场景1：标量 张量
    t1 = torch.IntTensor(10)
    print(f't1: {t1}, type: {type(t1)}')
    print('-'*30)

    # 场景2：列表 --&gt; 张量
    data = [[1,2,3],[4,5,6]]
    t2 = torch.IntTensor(data)
    print(f't2: {t2}, type: {type(t2)}')
    print('-'*30)

    # 场景3：numpy nd数组 --&gt; 张量
    data = np.random.randint(1,10,size=(2,3))
    t3 = torch.IntTensor(data)
    print(f't3: {t3}, type: {type(t3)}')
    print('-'*30)
    # 场景4：如果类型不匹配，会尝试自动转换类型
    data = np.random.randint(1,10,size=(2,3))
    t4 = torch.FloatTensor(data)        #默认：float32
    print(f't4: {t4}, type: {type(t4)}')

# 4.定义测试函数
if __name__ == "__main__":
    # dm01()        #掌握
    # dm02()
    dm03()
</code></pre>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="技术"></category>
  </entry>
  <entry>
    <title>赶紧考完放假</title>
    <link href="https://lzwpluto.github.io/posts/%E8%B5%B6%E7%B4%A7%E8%80%83%E5%AE%8C%E6%94%BE%E5%81%87/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E8%B5%B6%E7%B4%A7%E8%80%83%E5%AE%8C%E6%94%BE%E5%81%87/</id>
    <published>2026-01-09T00:00:00.000Z</published>
    <updated>2026-01-09T00:00:00.000Z</updated>
    <summary>快考完呀！</summary>
    <content type="html"><![CDATA[<p>概率论 100分
英语、马原 100分
复变函数、电路分析 100分
大学物理 100分</p>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="考试"></category>
  </entry>
  <entry>
    <title>马克思主义原理作业</title>
    <link href="https://lzwpluto.github.io/posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/</id>
    <published>2026-01-04T00:00:00.000Z</published>
    <updated>2026-01-04T00:00:00.000Z</updated>
    <summary>马原作业</summary>
    <content type="html"><![CDATA[<p>读《解放思想，实事求是，团结一致向前看》这篇讲话稿，那些文字让我陷入了思考。这是邓小平同志在1978年12月13日中央工作会议上的讲话，几天后，党的十一届三中全会召开，中国开启了改革开放的新征程。作为西安电子科技大学一名大二学生，我起初觉得这篇文章离我很远，但细读之后发现，其中的道理对电子信息类专业的学习、生活乃至未来发展都有深刻指导意义。父亲常对我说，"读书要读进去，别光看表面"，这回我真体会了。</p>
<p>文章开门见山提出"解放思想是当前的一个重大政治问题"。邓小平同志说："一个党，一个国家，一个民族，如果一切从本本出发，思想僵化，迷信盛行，那它就不能前进。"这段话让我震撼。虽然讲的是国家大事，但放在电路分析课程中同样适用。回想刚学习电路定理时，我惯于高中那套死记硬背方法，觉得记住戴维南定理公式就能解题。但面对含受控源的复杂电路，光靠套公式根本行不通。第一次期中考试，我不顾一切地套用等效电路公式，结果多道题出错。那次失败让我明白，专业学习更需要解放思想，不能拘泥过去经验，要敢于打破思维定式。思想僵化导致事业停滞，学习方法僵化同样让成绩止步不前。</p>
<p>解放思想不仅是口号，更是行动。邓小平同志讲："只有思想解放了，我们才能正确地解决过去遗留问题，解决新出现的一系列问题。"这让我想到队伍科技活动。起初大家都照搬往年模式，做电路展示、焊接演示，毫无新意。后来队长提议搞"智能语音识别"项目，用STM32单片机实现简单声控，这个创意很新颖，但有同学担心太冒险，怕做不出来。队长对我们讲，"怕什么，试试就知道了"，最终在指导老师支持下，我们大胆尝试，结果项目获了校级奖。这件事让我体会到，敢于突破常规才能找到更好解决方案。思想解放就是要有这种勇气，不迷信权威，不害怕失败，敢于根据实际情况判断。</p>
<p>实事求是是另一核心观点。 邓小平同志强调："一个革命政党，就怕听不到人民声音，最可怕的是鸦雀无声。"他提出"三不主义"：不抓辫子，不扣帽子，不打棍子。这话针对党内民主，但对实验课程有启发。在小组实验报告中，有时为避免同学嘲笑，我们会隐藏真实数据，说些"安全"的套话。这样一来，讨论变走过场，解决不了实际问题。老师鼓励我们"畅所欲言"，就是营造实事求是氛围。只有每个人都敢说真话，我们才能发现问题，找到正确解决方法。记得大学物理实验，我测的数据与理论值相差很大，本想偷偷改掉，后来想"不能干这种事"，最后如实报告。老师没批评，反而带我用误差理论分析原因，让我学到更多。这就是实事求是价值所在，比得高分更重要。</p>
<p>邓小平同志特别强调"研究新情况，解决新问题"。他说："要向前看，就要及时研究新情况和解决新问题，否则我们就不可能顺利前进。"这对我们应对课程难度变化有指导意义。大二是学习压力增大阶段，每学期都可能出现新情况——有时是复变函数概念理解不透，有时是线性代数矩阵运算不熟练，有时是电路频率响应分析不清。若用一成不变方法应对，肯定效果不好。我有个同学，大一成绩很好，大二学信号与系统时仍用原来方法，结果几次测验都不理想，他急得团团转。后来他调整策略，针对薄弱环节制定专项计划，成绩很快提升。这说明，只有实事求是看待自己变化，及时调整方法，才能持续进步。</p>
<p>文章中"处理遗留问题为的是向前看"论述，也让我有感触。 邓小平同志说："凡是过去搞错了的东西，统统应该改正。"同时指出："向后看是为更好向前看，不是引导人们向后看，去纠缠历史旧账。"这种既重视历史又不纠缠历史的态度，体现大智慧。在我们学习生活中，也常会遇类似情况。比如某次模电考试没考好，若一直沉浸懊悔，反复纠结"要是当初多复习就好"，这情绪只会影响后续学习。正确做法是，承认失败，分析原因，把错题整理出来，然后放下包袱，集中精力准备下次考试。就像老师常说，"不要为打翻的牛奶哭泣"，过去就让它过去，关键是吸取教训继续前进。这道理听来简单，做起来很难，我花很长时间才学会，有时还会犯老毛病。校园里的银杏树叶变黄了，秋天不知不觉就来了。</p>
<p>团结一致向前看，是文章落脚点。邓小平同志说："全党全国各族人民同心同德，一心一意搞建设，这是历史发展的必然要求。"这种团结不是无原则妥协，而是在解放思想、实事求是基础上形成的共识。我们队参加电子设计大赛时，三人小组能力水平不同，若只计较个人表现，团队肯定完不成作品。但当我们放下私心，把目标放在共同获奖上，互相鼓励，默契配合，最终拿到了省级奖项。这种团结一致向前看精神，放之四海而皆准。国家发展需全国人民齐心协力，队伍进步需全体同学共同努力，个人成长也需协调好学习与生活各方面。这道理，我们辅导员天天讲，但真正体会，还是在那次比赛以后，印象特别深刻。</p>
<p>文章还提到"要允许一部分地区、一部分企业、一部分工人农民，由于辛勤努力成绩大而收入先多一些"。 这在当时是打破平均主义的重要思想。对我们而言，意味着要承认差异，鼓励先进。队伍里有些同学学习特别刻苦，成绩优秀，他们理应得到表扬奖励。这不仅能激励他们继续努力，也能为其他同学树立榜样。若搞"大锅饭"，不管努力与否都得同样评价，那谁还愿刻苦学习？当然，我们作为集体一员，先进者也有责任帮助后进同学，最终实现共同进步。这种"先富带后富"思路，在队伍建设中同样适用，大家都是一个队伍成员，不能光自己好。</p>
<p>邓小平同志特别强调"要责任到人，有职有权有责"。他说："责任到人就要权责统一，有责任的人就要有相应权力。"在小组合作项目中，这道理很明显。若组长只有责任没有权力，组员不听安排，任务就无法完成；反过来，若权力很大却不承担责任，出了问题互相推诿，合作也会失败。只有当每个人既有明确分工，又有相应自主权，同时为自己部分负责，小组合作才能高效运转。学生会选举时，候选人都会发表竞选演说，承诺当选后会做些什么，这其实就是权责统一体现，不能光吃馒头不干活。</p>
<p>文章最后提出"全党同志一定要善于学习，善于重新学习"。邓小平同志说："学习什么？根本的是要学习马列主义、毛泽东思想。"虽时代不同，但终身学习理念永不过时。作为大学生，我们正处在学习黄金时期，但学习不应仅为应付考试。我们要学会学习方法，培养独立思考能力，这样才能适应未来社会变化。现在知识更新换代很快，大学学的知识可能毕业时就部分过时，只有具备持续学习能力，才能不断跟上时代步伐。我们老师常说，"活到老学到老"，说的就是这个道理，而且一辈子都管用。</p>
<p>读完这篇文章，我深深感受到老一辈革命家远见卓识。他们不仅看到当时中国面临的问题，更指明了前进方向。四十多年过去了，我们今天依然在改革开放，依然需要解放思想、实事求是。这让我想起老师说过一句话："日光之下并无新事，今天的很多问题，历史上都曾以不同形式出现过。"所以读经典文章，不仅是了解历史，更是汲取智慧，指导当下。作为当代青年，我们生逢其时，既享受改革开放成果，也肩负着继往开来使命。在学习中，我们要有解放思想勇气，敢于质疑，敢于创新；要有实事求是态度，脚踏实地，不弄虚作假；要有团结合作意识，与同学共同进步。只有这样，我们才能成长为对国家、对社会有用人才，在新时代长征路上贡献自己力量。这篇文章不仅是历史文献，更是一面镜子，映照过去，也照亮未来。每次重读，都能获得新启发，这或许就是经典作品魅力所在。</p>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="作业"></category>
  </entry>
  <entry>
    <title>Arch Linux 极简安装步骤指南</title>
    <link href="https://lzwpluto.github.io/posts/test/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/test/</id>
    <published>2026-01-03T00:00:00.000Z</published>
    <updated>2026-01-03T00:00:00.000Z</updated>
    <summary>适配新手的 Arch Linux 极简安装流程，覆盖 UEFI 引导、分区、基础配置核心步骤，步骤清晰可直接跟随操作</summary>
    <content type="html"><![CDATA[<p>Arch Linux 以轻量、灵活、滚动更新为核心特色，适合有基础 Linux 认知的用户使用。本文整理极简安装流程，聚焦 UEFI 引导模式下的核心步骤，省略非必要优化，帮助快速完成系统部署，全程附带命令注释和注意事项。</p>
<p>一、安装前准备</p>
<ol>
<li>
<p>下载 Arch Linux 镜像：前往Arch Linux 官网 下载最新镜像，推荐选择国内镜像源（如阿里云、清华大学镜像）提升下载速度。</p>
</li>
<li>
<p>制作启动 U 盘：</p>
</li>
</ol>
<ul>
<li>
<p>Windows 系统：使用 Rufus，选择下载的镜像文件，分区类型设为「GPT」，目标系统类型选「UEFI」，点击「开始」写入。</p>
</li>
<li>
<p>Linux/macOS 系统：使用 BalenaEtcher 或 dd 命令（sudo dd if=archlinux.iso of=/dev/sdX bs=4M status=progress，注意将 /dev/sdX 替换为 U 盘设备名）。</p>
</li>
</ul>
<ol>
<li>
<p>确认硬件条件：目标设备支持 UEFI 启动（进入 BIOS/UEFI 界面可查看），预留至少 20GB 磁盘空间，提前准备有线网络（无线网络需后续额外配置）。</p>
</li>
<li>
<p>备份数据：安装过程会格式化磁盘，务必备份目标磁盘上的重要数据。</p>
</li>
</ol>
<p>二、开始安装（进入 Live 环境）</p>
<ol>
<li>启动并进入 Arch Live 环境</li>
</ol>
<p>将制作好的启动 U 盘插入目标设备，开机选择从 U 盘启动，进入 Arch Linux 启动菜单后，选择「Arch Linux install medium (x86_64, UEFI)」，等待加载完成后进入命令行 Live 环境（默认以 root 用户登录）。</p>
<ol>
<li>验证 UEFI 启动模式</li>
</ol>
<p>执行以下命令，若能列出目录内容，说明当前为 UEFI 模式，符合后续安装要求；若目录不存在，需切换为 UEFI 启动或调整为 BIOS 安装流程：</p>
<p>ls /sys/firmware/efi/efivars</p>
<ol>
<li>配置网络连接</li>
</ol>
<p>网络连接是安装的核心前提，优先使用有线网络（插上网线即可自动获取 IP），无线网络需手动配置：</p>
<p>（1）验证网络连通性</p>
<p>ping baidu.com -c 3  #  ping 3 次百度，成功返回则网络正常</p>
<p>（2）无线网络配置（无有线时）</p>
<p>iwctl  # 进入无线管理交互模式
device list  # 列出无线设备（通常为 wlan0）
station wlan0 scan  # 扫描周边 WiFi
station wlan0 get-networks  # 显示可用 WiFi 名称
station wlan0 connect "WiFi名称"  # 连接 WiFi，按提示输入密码
exit  # 退出 iwctl 模式</p>
<ol>
<li>磁盘分区（UEFI + GPT 分区表）</li>
</ol>
<p>使用 cfdisk 工具进行分区，以目标磁盘为 /dev/sda 为例（实际使用时需通过 lsblk 命令确认磁盘名称，避免误操作）：</p>
<p>cfdisk /dev/sda  # 进入分区工具，选择 GPT 分区表</p>
<p>推荐分区方案（适用于单系统）：</p>
<p>分区路径</p>
<p>分区大小</p>
<p>分区类型</p>
<p>用途</p>
<p>/dev/sda1</p>
<p>512M</p>
<p>EFI System</p>
<p>UEFI 引导分区</p>
<p>/dev/sda2</p>
<p>剩余全部空间</p>
<p>Linux filesystem</p>
<p>根分区（/）</p>
<p>分区操作步骤：</p>
<ol>
<li>
<p>在 cfdisk 界面，选择「Free space」，按 Enter 键选择「New」，输入分区大小（如 512M），创建 EFI 分区。</p>
</li>
<li>
<p>选中新建的分区，按 Enter 键选择「Type」，找到「EFI System」并确认。</p>
</li>
<li>
<p>选中剩余的 Free space，重复步骤 1 创建根分区，分区类型默认「Linux filesystem」即可。</p>
</li>
<li>
<p>选择「Write」，输入 yes 确认写入分区表，然后选择「Quit」退出 cfdisk。</p>
</li>
<li>
<p>格式化分区</p>
</li>
</ol>
<p>分区完成后，对每个分区进行格式化（EFI 分区格式化为 FAT32，根分区格式化为 ext4）：</p>
<p>mkfs.fat -F32 /dev/sda1  # 格式化 EFI 分区
mkfs.ext4 /dev/sda2      # 格式化根分区（会清除数据，确认无误再执行）</p>
<ol>
<li>挂载分区</li>
</ol>
<p>先挂载根分区到 /mnt，再创建 EFI 分区挂载目录并挂载：</p>
<p>mount /dev/sda2 /mnt  # 挂载根分区
mkdir -p /mnt/boot/efi  # 创建 EFI 分区挂载目录
mount /dev/sda1 /mnt/boot/efi  # 挂载 EFI 分区</p>
<ol>
<li>安装基础系统组件</li>
</ol>
<p>使用 pacstrap 命令安装基础系统、内核、固件等核心组件：</p>
<p>pacstrap /mnt base linux linux-firmware base-devel vim networkmanager</p>
<p>组件说明：</p>
<ul>
<li>
<p>base：Arch Linux 基础系统组件，必装。</p>
</li>
<li>
<p>linux：Linux 内核，必装。</p>
</li>
<li>
<p>linux-firmware：硬件固件，解决多数网卡、显卡等硬件兼容性问题。</p>
</li>
<li>
<p>base-devel：开发工具集，后续安装软件时可能需要。</p>
</li>
<li>
<p>vim：文本编辑器，用于后续配置文件修改。</p>
</li>
<li>
<p>networkmanager：网络管理工具，后续管理有线/无线网络。</p>
</li>
</ul>
<ol>
<li>生成 fstab 文件（自动挂载分区）</li>
</ol>
<p>fstab 文件用于系统启动时自动挂载分区，执行以下命令生成并写入：</p>
<p>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</p>
<p>生成后可通过以下命令验证，确保分区信息正确：</p>
<p>cat /mnt/etc/fstab</p>
<ol>
<li>进入新安装的系统</li>
</ol>
<p>通过 arch-chroot 命令切换根目录到新安装的系统：</p>
<p>arch-chroot /mnt</p>
<ol>
<li>系统基础配置</li>
</ol>
<p>（1）设置时区</p>
<p>以上海时区为例，执行以下命令：</p>
<p>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  # 链接时区文件
hwclock --systohc  # 同步系统时间到硬件时钟</p>
<p>（2）配置本地化</p>
<p>编辑 locale.gen 文件，取消 en_US.UTF-8 和 zh_CN.UTF-8 的注释（去掉前面的 #）：</p>
<p>vim /etc/locale.gen</p>
<p>保存退出后，生成 locale：</p>
<p>locale-gen</p>
<p>设置默认 locale：</p>
<p>echo "LANG=en_US.UTF-8" &gt; /etc/locale.conf</p>
<p>（3）设置主机名</p>
<p>将「arch-pc」替换为你想要的主机名（如 my-arch）：</p>
<p>echo "arch-pc" &gt; /etc/hostname</p>
<p>（4）设置 root 密码</p>
<p>执行以下命令，按提示输入并确认密码（密码输入时不显示，正常现象）：</p>
<p>passwd</p>
<ol>
<li>安装并配置引导程序（GRUB）</li>
</ol>
<p>安装 GRUB 引导程序及 UEFI 相关组件：</p>
<p>pacman -S grub efibootmgr</p>
<p>将 GRUB 安装到 EFI 分区：</p>
<p>grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB</p>
<p>生成 GRUB 配置文件：</p>
<p>grub-mkconfig -o /boot/grub/grub.cfg</p>
<ol>
<li>启用网络服务</li>
</ol>
<p>设置 NetworkManager 开机自启，确保系统启动后自动连接网络：</p>
<p>systemctl enable NetworkManager
systemctl start NetworkManager  # 立即启动网络服务</p>
<ol>
<li>完成安装，重启系统</li>
</ol>
<p>依次执行以下命令，退出 chroot 环境、卸载分区并重启：</p>
<p>exit  # 退出 chroot 环境
umount -R /mnt  # 卸载所有挂载的分区
reboot  # 重启系统，重启前记得拔掉启动 U 盘</p>
<p>三、后续优化（可选）</p>
<ol>
<li>
<p>创建普通用户：root 用户权限过高，日常使用建议创建普通用户（将「username」替换为你的用户名）：useradd -m username  # 创建用户并生成家目录
passwd username  # 为普通用户设置密码
usermod -aG wheel username  # 将用户添加到 wheel 组（获取 sudo 权限）
visudo  # 编辑 sudo 配置，取消 wheel 组注释（允许 wheel 组用户使用 sudo）</p>
</li>
<li>
<p>安装桌面环境：若需要图形界面，可安装 GNOME、KDE 等桌面环境（以 GNOME 为例）：
pacman -S gnome gdm
systemctl enable gdm  # 启用 GDM 登录管理器，开机自动进入图形界面</p>
</li>
<li>
<p>安装显卡驱动：根据显卡型号安装对应驱动（NVIDIA 显卡示例）：
pacman -S nvidia nvidia-utils</p>
</li>
<li>
<p>更换国内镜像源：编辑 /etc/pacman.d/mirrorlist，将国内镜像源（如阿里云、清华大学）放在前面，提升软件下载速度。</p>
</li>
</ol>
<p>四、常见问题排查</p>
<ol>
<li>
<p>网络连接失败：优先检查网线是否插好，无线连接需确认 WiFi 名称和密码正确；若扫描不到 WiFi，可能是缺少无线网卡固件，可重新进入 Live 环境，通过 pacstrap 安装对应的固件包。</p>
</li>
<li>
<p>引导失败：检查 GRUB 安装步骤是否正确，可重新进入 Live 环境，挂载分区后重新生成 GRUB 配置文件（grub-mkconfig -o /boot/grub/grub.cfg）。</p>
</li>
<li>
<p>系统启动后无网络：确认 NetworkManager 服务已启用，可通过 systemctl status NetworkManager 查看服务状态，异常则执行 systemctl restart NetworkManager 重启服务。</p>
</li>
<li>
<p>分区时误操作：若误删分区，停止所有操作，可尝试使用 testdisk 工具恢复分区表（需提前准备 testdisk 工具或包含该工具的 Live 镜像）。</p>
</li>
</ol>
<p>通过以上步骤即可完成 Arch Linux 的基础安装，后续可根据个人需求安装软件、配置环境。若需更详细的优化教程，可关注后续博客更新。</p>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="技术笔记"></category>
  </entry>
  <entry>
    <title>Simple Guides for Mizuki</title>
    <link href="https://lzwpluto.github.io/posts/guide/" rel="alternate" type="text/html"/>
    <id>https://lzwpluto.github.io/posts/guide/</id>
    <published>2024-04-01T00:00:00.000Z</published>
    <updated>2024-04-01T00:00:00.000Z</updated>
    <summary>How to use this blog template.</summary>
    <content type="html"><![CDATA[<p>This blog template is built with <a href="https://astro.build/">Astro</a>. For the things that are not mentioned in this guide, you may find the answers in the <a href="https://docs.astro.build/">Astro Docs</a>.</p>
<h2>Front-matter of Posts</h2>
<pre><code>---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
</code></pre>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>title</code></td>
<td>The title of the post.</td>
</tr>
<tr>
<td><code>published</code></td>
<td>The date the post was published.</td>
</tr>
<tr>
<td><code>pinned</code></td>
<td>Whether this post is pinned to the top of the post list.</td>
</tr>
<tr>
<td><code>priority</code></td>
<td>The priority of the pinned post. Smaller value means higher priority (0, 1, 2...).</td>
</tr>
<tr>
<td><code>description</code></td>
<td>A short description of the post. Displayed on index page.</td>
</tr>
<tr>
<td><code>image</code></td>
<td>The cover image path of the post.&lt;br/&gt;1. Start with <code>http://</code> or <code>https://</code>: Use web image&lt;br/&gt;2. Start with <code>/</code>: For image in <code>public</code> dir&lt;br/&gt;3. With none of the prefixes: Relative to the markdown file</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>The tags of the post.</td>
</tr>
<tr>
<td><code>category</code></td>
<td>The category of the post.</td>
</tr>
<tr>
<td><code>licenseName</code></td>
<td>The license name for the post content.</td>
</tr>
<tr>
<td><code>author</code></td>
<td>The author of the post.</td>
</tr>
<tr>
<td><code>sourceLink</code></td>
<td>The source link or reference for the post content.</td>
</tr>
<tr>
<td><code>draft</code></td>
<td>If this post is still a draft, which won't be displayed.</td>
</tr>
</tbody>
</table>
<h2>Where to Place the Post Files</h2>
<p>Your post files should be placed in <code>src/content/posts/</code> directory. You can also create sub-directories to better organize your posts and assets.</p>
<pre><code>src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
</code></pre>
]]></content>
    <author>
      <name>Pluto</name>
    </author>
    <category term="Guides"></category>
  </entry>
</feed>