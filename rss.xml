<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Pluto</title><description>One demo website</description><link>https://lzwpluto.github.io/</link><language>zh_CN</language><item><title>张量的基本运算</title><link>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</guid><description>张量的基本运算</description><pubDate>Mon, 19 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;day02.02_张量的基本运算&lt;/h1&gt;
&lt;h2&gt;Docstring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;案例：
演示张量的基本运算操作，包括加法、减法、乘法和除法。&lt;/p&gt;
&lt;p&gt;涉及到的API：
add(), sub(), mul(), div(), neg() --&amp;gt; 张量的加法、减法、乘法、除法和取负操作
add_(), sub_(), mul_(), div_() --&amp;gt; 张量的加法、减法、乘法、除法的原地操作(可以修改源数据, 类似于C语言中++c和c++的区别)&lt;/p&gt;
&lt;p&gt;掌握：
+, -, *, /&lt;/p&gt;
&lt;p&gt;掌握：
1.可以用+、-、*、/进行张量的基本运算
2.如果是张量和数值运算，则：张量的每个元素都和该数值进行运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 导包
import torch

# 1.创建张量
t1 = torch.tensor([1, 2, 3])

# 2.张量的加法
# t2 = t1.add(10) # 不会修改源数据
# t2 = t1 + 10  # 不会修改源数据
# t1.add_(10) # 会修改源数据
#t1 += 10 # 会修改源数据


# 其他运算类似
# t2 = t1.sub(1)
# t2 = t1.mul(2)
# t2 = t1.div(2)  # 有小数
# t2 = t1.neg()  # 取负数
t2 = t1 // 2
# 3.打印结果
print(f&apos;t1:{t1}&apos;)
print(f&apos;t2:{t2}&apos;)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>张量类型转换</title><link>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>张量类型转换</description><pubDate>Mon, 19 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;04_张量类型转换&lt;/h1&gt;
&lt;h2&gt;Docstring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;案例：
创建指定类型的张量&lt;/p&gt;
&lt;p&gt;涉及到的函数如下：
torch.type （torch支持的数据类型）
torch.half, torch.float, torch.double, torch.short, torch.int, torch.long&lt;/p&gt;
&lt;p&gt;需要掌握的函数：
torch.type&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 导包
import torch

# 场景1: 直接创建指定类型的张量
t1 = torch.tensor(data=[1, 2, 3, 4, 5], dtype=torch.float) # 默认是torch.float32
print(f&apos;t1: {t1}, (元素)type: {t1.dtype}, (张量)type: {type(t1)}&apos;)
print(&apos;-&apos; * 30)

# 场景2: 创建好张量后，进行类型转换
# 思路1：使用.type()方法
t2 = t1.type(torch.int16)
print(f&apos;t2: {t2}, (元素)type: {t2.dtype}, (张量)type: {type(t2)}&apos;)
print(&apos;-&apos; * 30)

# 思路2：使用专用的转换函数
print(t2.half()) # 转换为float16
print(t2.float()) # 转换为float32
print(t2.double()) # 转换为float64
print(t2.short()) # 转换为int16
print(t2.int()) # 转换为int32
print(t2.long()) # 转换为int64
print(&apos;-&apos; * 30)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>创建全0全1指定值张量</title><link>https://lzwpluto.github.io/posts/%E5%88%9B%E5%BB%BA%E5%85%A80%E5%85%A81%E6%8C%87%E5%AE%9A%E5%80%BC%E5%BC%A0%E9%87%8F/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E5%88%9B%E5%BB%BA%E5%85%A80%E5%85%A81%E6%8C%87%E5%AE%9A%E5%80%BC%E5%BC%A0%E9%87%8F/</guid><description>创建全0全1指定值张量</description><pubDate>Mon, 19 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;03_创建全0全1指定值张量&lt;/h1&gt;
&lt;h2&gt;Docstring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;案例：
演示如何创建全0张量、全1张量以及指定值张量。&lt;/p&gt;
&lt;p&gt;涉及到的函数如下：
torch.ones 和 torch.ones_like - 创建全1张量
torch.zeros 和 torch.zeros_like - 创建全0张量
torch.full 和 torch.full_like - 创建指定值张量&lt;/p&gt;
&lt;p&gt;需要掌握的函数：
torch.zeros, torch.full&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 导包
import torch

# 场景1: torch.ones 和 torch.ones_like 创建全1张量
t1 = torch.ones(2, 3)
print(f&apos;t1: {t1}, type: {type(t1)}&apos;)
print(&apos;-&apos; * 30)
t2 = torch.tensor([[1, 2], [3, 4], [5, 6]])
print(f&apos;t2: {t2}, type: {type(t2)}&apos;)
print(&apos;-&apos; * 30)
# t3 --&amp;gt; 基于t2创建一个全1张量
t3 = torch.ones_like(t2)
print(f&apos;t3: {t3}, type: {type(t3)}&apos;)
print(&apos;-&apos; * 30)

# 场景2: torch.zeros 和 torch.zeros_like 创建全0张量
t4 = torch.zeros(2, 4)
print(f&apos;t4: {t4}, type: {type(t4)}&apos;)
print(&apos;-&apos; * 30)
t5 = torch.tensor([[7, 8, 9], [10, 11, 12]])
print(f&apos;t5: {t5}, type: {type(t5)}&apos;)
print(&apos;-&apos; * 30)
# t6 --&amp;gt; 基于t5创建一个全0张量
t6 = torch.zeros_like(t5)
print(f&apos;t6: {t6}, type: {type(t6)}&apos;)
print(&apos;-&apos; * 30)

# 场景3: torch.full 和 torch.full_like 创建指定值张量
t4 = torch.full(size=(2,3), fill_value=255) # 创建一个2行3列，值为255的张量
print(f&apos;t4: {t4}, type: {type(t4)}&apos;)
print(&apos;-&apos; * 30)

t5 = torch.tensor([[7, 8, 9], [10, 11, 12]])
print(f&apos;t5: {t5}, type: {type(t5)}&apos;)
print(&apos;-&apos; * 30)
# t6 --&amp;gt; 基于t5创建一个全0张量
t6 = torch.full_like(t5, fill_value=255)
print(f&apos;t6: {t6}, type: {type(t6)}&apos;)
print(&apos;-&apos; * 30)
# 函数测试
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>创建线性和随机张量</title><link>https://lzwpluto.github.io/posts/%E5%88%9B%E5%BB%BA%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9A%8F%E6%9C%BA%E5%BC%A0%E9%87%8F/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E5%88%9B%E5%BB%BA%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9A%8F%E6%9C%BA%E5%BC%A0%E9%87%8F/</guid><description>创建线性和随机张量</description><pubDate>Mon, 19 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;02_创建线性和随机张量&lt;/h1&gt;
&lt;h2&gt;Docstring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;案例：演示创建线性张量和随机张量的方式&lt;/p&gt;
&lt;p&gt;涉及到的函数：
torch.arange 和 torch.linspace 创建线性张量
torch.random.initial_seed 和 torch.random.manual_seed 设置随机种子
torch.rand/randn 创建随机浮点类型张量
torch.randint(low, high, size=()) 创建随机整数类型张量&lt;/p&gt;
&lt;p&gt;要掌握的函数：
torch.arrange
torch.linspace
torch.manual_seed
torch.randint&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 导包
import torch

# 1.定义函数，演示：torch.arange 和 torch.linspace 创建线性张量
def dm01():
    # 场景1：创建指定范围的线性张量
    # 参1：起始值，参2：终止值（不包含），参3：步长
    t1 = torch.arange(0,10,2)
    print(f&apos;t1: {t1}, type: {type(t1)}&apos;)
    print(&apos;-&apos;*30)

    # 场景2：创建指定范围和指定个数的线性等差数列
    # 参1：起始值，参2：终止值（包含），参3：元素个数
    t2 = torch.linspace(1,10,4)
    print(f&apos;t2: {t2}, type: {type(t2)}&apos;)


# 2.定义函数，演示：torch.random.initial_seed 和 torch.random.manual_seed 设置随机种子
def dm02():
    # step1：设置随机种子
    #torch.initial_seed()        # 默认使用系统时间戳作为随机种子
    torch.manual_seed(3)      # 设置随机种子


    # step2：创建随机张量
    # 场景1：均匀分布的（0，1）随机张量
    t1 = torch.rand(2,3)
    print(f&apos;t1: {t1}, type: {type(t1)}&apos;)
    print(&apos;-&apos;*30)

    # 场景2：正态分布的随机张量
    t2 = torch.randn(2,3)
    print(f&apos;t2: {t2}, type: {type(t2)}&apos;)
    print(&apos;-&apos;*30)

    # 场景3：创建随机整数张量
    t3 = torch.randint(1,10,size=(3,5))
    print(f&apos;t3: {t3}, type: {type(t3)}&apos;)


# 3.测试函数
if __name__ == &quot;__main__&quot;:
    # dm01()
    dm02()
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>张量的点乘和矩阵乘法</title><link>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E7%82%B9%E4%B9%98%E5%92%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E7%82%B9%E4%B9%98%E5%92%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</guid><description>张量的点乘和矩阵乘法</description><pubDate>Mon, 19 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;day02.03_张量的点乘和矩阵乘法&lt;/h1&gt;
&lt;h2&gt;Docstring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;案例：
演示张量的点乘和矩阵乘法操作。
点乘：
要求：两个张量的维度必须相同，对应位置的元素直接做相应的操作
API：
t1 * t2
t1.mul(t2)  #nultiply: 点乘
矩阵乘法：
要求：两个张量，第一个张量的列数，等于第二个张量的行数（A列=B行）
结果：A行B列
API：
t1 @ t2
t1.matmul(t2)  # matrix multiply: 矩阵乘法
t1.dot(t2)     # 扩展：只针对于一维张量有效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 导包
import torch

# 1.定义函数，演示张量：点乘
def dm01():
    # 1.定义张量，2行3列
    t1 = torch.tensor([[1, 2, 3],[4, 5, 6]])
    print(f&apos;t1: {t1}&apos;)

    # 2.定义张量，2行3列
    t2 = torch.tensor([[1, 2, 3],[4, 5, 6]])
    print(f&apos;t2: {t2}&apos;)

    # 3.点乘
    # t3 = t1 * t2
    t3 = t1.mul(t2) #效果同上
    # 4.打印结果
    print(f&apos;t3: {t3}&apos;)

# 2.定义函数，演示张量：矩阵乘法
def dm02():
    # 条件：A列 = B行，结果：A行B列
    # 1.定义张量，2行3列
    t1 = torch.tensor([[1, 2, 3],[4, 5, 6]])
    print(f&apos;t1: {t1}&apos;)

    # 2.定义张量，2行3列
    t2 = torch.tensor([[7, 8],[9, 10],[11, 12]])
    print(f&apos;t2: {t2}&apos;)

    # 3.矩阵乘法
    t3 = t1 @ t2
    # t3 = t1.matmul(t2) #效果同上,matrix multiply(矩阵乘法)

    # 4.打印结果
    print(f&apos;t3: {t3}&apos;)

    # 5.演示dot()函数
    # t3 = t1.dot(t2) # 报错
    t4 = torch.tensor([1, 2, 3])
    t5 = torch.tensor([4, 5, 6])
    t6 = t4.dot(t5)
    print(f&apos;t6: {t6}&apos;)

# 3.调用函数，测试
if __name__ == &apos;__main__&apos;:
    dm01()
    dm02()
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>张量和numpy之间相互转换</title><link>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E5%92%8Cnumpy%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E5%92%8Cnumpy%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</guid><description>张量和numpy之间相互转换</description><pubDate>Mon, 19 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;day02.01_张量和numpy之间相互转换&lt;/h1&gt;
&lt;h2&gt;Docstring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;案例：
演示如何在PyTorch张量和NumPy数组之间进行相互转换，以及如何从标量中提取其内容&lt;/p&gt;
&lt;p&gt;涉及到的API：
场景1：张量 --&amp;gt; numpy nd数组对象
张量对象.numpy()         共享内存
张量对象.numpy().copy()  不共享内存, 链式编程写法,
场景2：numpy nd数组对象 --&amp;gt; 张量
from_numpy()             共享内存
torch.tensor(nd数组)     不共享内存
场景3：从标量张量中提取其内容
标量张量.item()&lt;/p&gt;
&lt;p&gt;掌握：
张量 --&amp;gt; numpy： 张量对象.numpy()
numpy --&amp;gt; 张量： torch.tensor(nd数组)
从标量张量中提取其内容： 标量张量.item()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 导包
import torch
import numpy as np

# 1. 定义函数，演示：张量 --&amp;gt; numpy
def dm01():
    # 1. 创建一个张量
    t1 = torch.tensor([1,2,3,4,5])
    print(f&apos;t1: {t1}, type: {type(t1)}&apos;)
    # 2. 张量 --&amp;gt; numpy
    # n1 = t1.numpy() # 共享内存
    n1 = t1.numpy().copy() # 不共享内存
    print(f&apos;n1: {n1}, type: {type(n1)}&apos;)
    # 3. 修改n1中的数据，观察t1的变化
    n1[0] = 100
    print(f&apos;n1: {n1}&apos;)
    print(f&apos;t1: {t1}&apos;)
    print(&apos;-&apos; * 30)

# 2. 定义函数，演示：numpy --&amp;gt; 张量
def dm02():
    # 1. 创建一个numpy nd数组对象
    n1 = np.array([10,20,30])
    print(f&apos;n1: {n1}, type: {type(n1)}&apos;)
    # 2. numpy --&amp;gt; 张量
    # t1 = torch.from_numpy(n1).type(torch.float32) # 转换+转类型
    t1 = torch.from_numpy(n1) # 共享内存
    print(f&apos;t1: {t1}, type: {type(t1)}&apos;)

    t2 = torch.tensor(n1) # 不共享内存
    print(f&apos;t2: {t2}, type: {type(t2)}&apos;)

    # 3. 修改n1中的数据，观察t1和t2的变化
    n1[0] = 200
    print(f&apos;n1: {n1}&apos;)
    print(f&apos;t1: {t1}&apos;)
    print(f&apos;t2: {t2}&apos;)
    print(&apos;-&apos; * 30)

# 3. 定义函数，演示：从标量张量(只有一个值的张量)中提取其内容
def dm03():
    # 1.创建张量
    t1 = torch.tensor(100)          # 标量张量，可以
    # t1 = torch.tensor([100, ])      # 可以
    # t1 = torch.tensor([100, 200])   # 注意：这里不是标量张量
    print(f&apos;t1: {t1}, type: {type(t1)}&apos;)
    # 2.提取标量张量中的内容
    a = t1.item()
    print(f&apos;value: {a}, type: {type(a)}&apos;)

# 4. 测试
if __name__ == &apos;__main__&apos;:
    #dm01()
    #dm02()
    dm03()
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>张量的基本创建方式</title><link>https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E5%BC%A0%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</guid><description>张量的基本创建方式</description><pubDate>Mon, 19 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;01_张量的基本创建方式&lt;/h1&gt;
&lt;h2&gt;Docstring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;案例：演示张量的基本创建方式&lt;/p&gt;
&lt;p&gt;张量：
Pytorch框架属于最常用的深度学习框架之一，无论是后续要学的ANN（人工神经网络）、CNN（卷积神经网络）、RNN（循环神经网络）等模型，都离不开张量的操作。
张量（Tensor）是Pytorch中最基本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;张量 -&amp;gt; 存储同一类元素的容器，且元素值必须是数值才可以
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;张良的基本创建方式：
torch.tensor 根据指定的数据创建
torch.Tensor 根据形状创建张量，其他可用来创建指定的张量
torch.IntTensor、 torch.FloatTensor、torch.DoubleTensor 根据指定的数据类型创建张量&lt;/p&gt;
&lt;p&gt;细节：
Tensor方式较之于tensor方式，可以直接创建指定形状的张量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 导包
import torch
import numpy as np

# 1.定义函数，演示：torch.tensor 根据指定的数据创建

def dm01():
    # 场景1：标量 张量
    t1 = torch.tensor(10)
    print(f&apos;t1: {t1}, type: {type(t1)}&apos;)
    print(&apos;-&apos;*30)

    # 场景2：列表 --&amp;gt; 张量
    data = [[1,2,3],[4,5,6]]
    t2 = torch.tensor(data)
    print(f&apos;t2: {t2}, type: {type(t2)}&apos;)
    print(&apos;-&apos;*30)

    # 场景3：numpy nd数组 --&amp;gt; 张量
    data = np.random.randint(1,10,size=(2,3))
    t3 = torch.tensor(data, dtype=torch.float32)
    print(f&apos;t3: {t3}, type: {type(t3)}&apos;)
    print(&apos;-&apos;*30)

    # 场景4：尝试直接创建 指定维度（例如2行3列的）张量
    # t4 = torch.tensor(data=2, dtype=3)
    # print(f&apos;t4: {t4}, type: {type(t4)}&apos;)

# 2.定义函数，演示：根据形状创建张量，其他可用来创建指定的张量
def dm02():
    # 场景1：标量 张量
    t1 = torch.Tensor(10)
    print(f&apos;t1: {t1}, type: {type(t1)}&apos;)
    print(&apos;-&apos;*30)

    # 场景2：列表 --&amp;gt; 张量
    data = [[1,2,3],[4,5,6]]
    t2 = torch.Tensor(data)
    print(f&apos;t2: {t2}, type: {type(t2)}&apos;)
    print(&apos;-&apos;*30)

    # 场景3：numpy nd数组 --&amp;gt; 张量
    data = np.random.randint(1,10,size=(2,3))
    t3 = torch.Tensor(data)
    print(f&apos;t3: {t3}, type: {type(t3)}&apos;)
    print(&apos;-&apos;*30)

    # 场景4：尝试直接创建 指定维度（例如2行3列的）张量
    t4 = torch.Tensor(2, 3)
    print(f&apos;t4: {t4}, type: {type(t4)}&apos;)

# 3.定义函数，演示：torch.IntTensor、 torch.FloatTensor、torch.DoubleTensor 根据指定的数据类型创建张量
def dm03():
    # 场景1：标量 张量
    t1 = torch.IntTensor(10)
    print(f&apos;t1: {t1}, type: {type(t1)}&apos;)
    print(&apos;-&apos;*30)

    # 场景2：列表 --&amp;gt; 张量
    data = [[1,2,3],[4,5,6]]
    t2 = torch.IntTensor(data)
    print(f&apos;t2: {t2}, type: {type(t2)}&apos;)
    print(&apos;-&apos;*30)

    # 场景3：numpy nd数组 --&amp;gt; 张量
    data = np.random.randint(1,10,size=(2,3))
    t3 = torch.IntTensor(data)
    print(f&apos;t3: {t3}, type: {type(t3)}&apos;)
    print(&apos;-&apos;*30)
    # 场景4：如果类型不匹配，会尝试自动转换类型
    data = np.random.randint(1,10,size=(2,3))
    t4 = torch.FloatTensor(data)        #默认：float32
    print(f&apos;t4: {t4}, type: {type(t4)}&apos;)

# 4.定义测试函数
if __name__ == &quot;__main__&quot;:
    # dm01()        #掌握
    # dm02()
    dm03()
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>赶紧考完放假</title><link>https://lzwpluto.github.io/posts/%E8%B5%B6%E7%B4%A7%E8%80%83%E5%AE%8C%E6%94%BE%E5%81%87/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E8%B5%B6%E7%B4%A7%E8%80%83%E5%AE%8C%E6%94%BE%E5%81%87/</guid><description>快考完呀！</description><pubDate>Fri, 09 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;概率论 100分
英语、马原 100分
复变函数、电路分析 100分
大学物理 100分&lt;/p&gt;
</content:encoded></item><item><title>马克思主义原理作业</title><link>https://lzwpluto.github.io/posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/</guid><description>马原作业</description><pubDate>Sun, 04 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;读《解放思想，实事求是，团结一致向前看》这篇讲话稿，那些文字让我陷入了思考。这是邓小平同志在1978年12月13日中央工作会议上的讲话，几天后，党的十一届三中全会召开，中国开启了改革开放的新征程。作为西安电子科技大学一名大二学生，我起初觉得这篇文章离我很远，但细读之后发现，其中的道理对电子信息类专业的学习、生活乃至未来发展都有深刻指导意义。父亲常对我说，&quot;读书要读进去，别光看表面&quot;，这回我真体会了。&lt;/p&gt;
&lt;p&gt;文章开门见山提出&quot;解放思想是当前的一个重大政治问题&quot;。邓小平同志说：&quot;一个党，一个国家，一个民族，如果一切从本本出发，思想僵化，迷信盛行，那它就不能前进。&quot;这段话让我震撼。虽然讲的是国家大事，但放在电路分析课程中同样适用。回想刚学习电路定理时，我惯于高中那套死记硬背方法，觉得记住戴维南定理公式就能解题。但面对含受控源的复杂电路，光靠套公式根本行不通。第一次期中考试，我不顾一切地套用等效电路公式，结果多道题出错。那次失败让我明白，专业学习更需要解放思想，不能拘泥过去经验，要敢于打破思维定式。思想僵化导致事业停滞，学习方法僵化同样让成绩止步不前。&lt;/p&gt;
&lt;p&gt;解放思想不仅是口号，更是行动。邓小平同志讲：&quot;只有思想解放了，我们才能正确地解决过去遗留问题，解决新出现的一系列问题。&quot;这让我想到队伍科技活动。起初大家都照搬往年模式，做电路展示、焊接演示，毫无新意。后来队长提议搞&quot;智能语音识别&quot;项目，用STM32单片机实现简单声控，这个创意很新颖，但有同学担心太冒险，怕做不出来。队长对我们讲，&quot;怕什么，试试就知道了&quot;，最终在指导老师支持下，我们大胆尝试，结果项目获了校级奖。这件事让我体会到，敢于突破常规才能找到更好解决方案。思想解放就是要有这种勇气，不迷信权威，不害怕失败，敢于根据实际情况判断。&lt;/p&gt;
&lt;p&gt;实事求是是另一核心观点。 邓小平同志强调：&quot;一个革命政党，就怕听不到人民声音，最可怕的是鸦雀无声。&quot;他提出&quot;三不主义&quot;：不抓辫子，不扣帽子，不打棍子。这话针对党内民主，但对实验课程有启发。在小组实验报告中，有时为避免同学嘲笑，我们会隐藏真实数据，说些&quot;安全&quot;的套话。这样一来，讨论变走过场，解决不了实际问题。老师鼓励我们&quot;畅所欲言&quot;，就是营造实事求是氛围。只有每个人都敢说真话，我们才能发现问题，找到正确解决方法。记得大学物理实验，我测的数据与理论值相差很大，本想偷偷改掉，后来想&quot;不能干这种事&quot;，最后如实报告。老师没批评，反而带我用误差理论分析原因，让我学到更多。这就是实事求是价值所在，比得高分更重要。&lt;/p&gt;
&lt;p&gt;邓小平同志特别强调&quot;研究新情况，解决新问题&quot;。他说：&quot;要向前看，就要及时研究新情况和解决新问题，否则我们就不可能顺利前进。&quot;这对我们应对课程难度变化有指导意义。大二是学习压力增大阶段，每学期都可能出现新情况——有时是复变函数概念理解不透，有时是线性代数矩阵运算不熟练，有时是电路频率响应分析不清。若用一成不变方法应对，肯定效果不好。我有个同学，大一成绩很好，大二学信号与系统时仍用原来方法，结果几次测验都不理想，他急得团团转。后来他调整策略，针对薄弱环节制定专项计划，成绩很快提升。这说明，只有实事求是看待自己变化，及时调整方法，才能持续进步。&lt;/p&gt;
&lt;p&gt;文章中&quot;处理遗留问题为的是向前看&quot;论述，也让我有感触。 邓小平同志说：&quot;凡是过去搞错了的东西，统统应该改正。&quot;同时指出：&quot;向后看是为更好向前看，不是引导人们向后看，去纠缠历史旧账。&quot;这种既重视历史又不纠缠历史的态度，体现大智慧。在我们学习生活中，也常会遇类似情况。比如某次模电考试没考好，若一直沉浸懊悔，反复纠结&quot;要是当初多复习就好&quot;，这情绪只会影响后续学习。正确做法是，承认失败，分析原因，把错题整理出来，然后放下包袱，集中精力准备下次考试。就像老师常说，&quot;不要为打翻的牛奶哭泣&quot;，过去就让它过去，关键是吸取教训继续前进。这道理听来简单，做起来很难，我花很长时间才学会，有时还会犯老毛病。校园里的银杏树叶变黄了，秋天不知不觉就来了。&lt;/p&gt;
&lt;p&gt;团结一致向前看，是文章落脚点。邓小平同志说：&quot;全党全国各族人民同心同德，一心一意搞建设，这是历史发展的必然要求。&quot;这种团结不是无原则妥协，而是在解放思想、实事求是基础上形成的共识。我们队参加电子设计大赛时，三人小组能力水平不同，若只计较个人表现，团队肯定完不成作品。但当我们放下私心，把目标放在共同获奖上，互相鼓励，默契配合，最终拿到了省级奖项。这种团结一致向前看精神，放之四海而皆准。国家发展需全国人民齐心协力，队伍进步需全体同学共同努力，个人成长也需协调好学习与生活各方面。这道理，我们辅导员天天讲，但真正体会，还是在那次比赛以后，印象特别深刻。&lt;/p&gt;
&lt;p&gt;文章还提到&quot;要允许一部分地区、一部分企业、一部分工人农民，由于辛勤努力成绩大而收入先多一些&quot;。 这在当时是打破平均主义的重要思想。对我们而言，意味着要承认差异，鼓励先进。队伍里有些同学学习特别刻苦，成绩优秀，他们理应得到表扬奖励。这不仅能激励他们继续努力，也能为其他同学树立榜样。若搞&quot;大锅饭&quot;，不管努力与否都得同样评价，那谁还愿刻苦学习？当然，我们作为集体一员，先进者也有责任帮助后进同学，最终实现共同进步。这种&quot;先富带后富&quot;思路，在队伍建设中同样适用，大家都是一个队伍成员，不能光自己好。&lt;/p&gt;
&lt;p&gt;邓小平同志特别强调&quot;要责任到人，有职有权有责&quot;。他说：&quot;责任到人就要权责统一，有责任的人就要有相应权力。&quot;在小组合作项目中，这道理很明显。若组长只有责任没有权力，组员不听安排，任务就无法完成；反过来，若权力很大却不承担责任，出了问题互相推诿，合作也会失败。只有当每个人既有明确分工，又有相应自主权，同时为自己部分负责，小组合作才能高效运转。学生会选举时，候选人都会发表竞选演说，承诺当选后会做些什么，这其实就是权责统一体现，不能光吃馒头不干活。&lt;/p&gt;
&lt;p&gt;文章最后提出&quot;全党同志一定要善于学习，善于重新学习&quot;。邓小平同志说：&quot;学习什么？根本的是要学习马列主义、毛泽东思想。&quot;虽时代不同，但终身学习理念永不过时。作为大学生，我们正处在学习黄金时期，但学习不应仅为应付考试。我们要学会学习方法，培养独立思考能力，这样才能适应未来社会变化。现在知识更新换代很快，大学学的知识可能毕业时就部分过时，只有具备持续学习能力，才能不断跟上时代步伐。我们老师常说，&quot;活到老学到老&quot;，说的就是这个道理，而且一辈子都管用。&lt;/p&gt;
&lt;p&gt;读完这篇文章，我深深感受到老一辈革命家远见卓识。他们不仅看到当时中国面临的问题，更指明了前进方向。四十多年过去了，我们今天依然在改革开放，依然需要解放思想、实事求是。这让我想起老师说过一句话：&quot;日光之下并无新事，今天的很多问题，历史上都曾以不同形式出现过。&quot;所以读经典文章，不仅是了解历史，更是汲取智慧，指导当下。作为当代青年，我们生逢其时，既享受改革开放成果，也肩负着继往开来使命。在学习中，我们要有解放思想勇气，敢于质疑，敢于创新；要有实事求是态度，脚踏实地，不弄虚作假；要有团结合作意识，与同学共同进步。只有这样，我们才能成长为对国家、对社会有用人才，在新时代长征路上贡献自己力量。这篇文章不仅是历史文献，更是一面镜子，映照过去，也照亮未来。每次重读，都能获得新启发，这或许就是经典作品魅力所在。&lt;/p&gt;
</content:encoded></item><item><title>Arch Linux 极简安装步骤指南</title><link>https://lzwpluto.github.io/posts/test/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/test/</guid><description>适配新手的 Arch Linux 极简安装流程，覆盖 UEFI 引导、分区、基础配置核心步骤，步骤清晰可直接跟随操作</description><pubDate>Sat, 03 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Arch Linux 以轻量、灵活、滚动更新为核心特色，适合有基础 Linux 认知的用户使用。本文整理极简安装流程，聚焦 UEFI 引导模式下的核心步骤，省略非必要优化，帮助快速完成系统部署，全程附带命令注释和注意事项。&lt;/p&gt;
&lt;p&gt;一、安装前准备&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载 Arch Linux 镜像：前往Arch Linux 官网 下载最新镜像，推荐选择国内镜像源（如阿里云、清华大学镜像）提升下载速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;制作启动 U 盘：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Windows 系统：使用 Rufus，选择下载的镜像文件，分区类型设为「GPT」，目标系统类型选「UEFI」，点击「开始」写入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux/macOS 系统：使用 BalenaEtcher 或 dd 命令（sudo dd if=archlinux.iso of=/dev/sdX bs=4M status=progress，注意将 /dev/sdX 替换为 U 盘设备名）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;确认硬件条件：目标设备支持 UEFI 启动（进入 BIOS/UEFI 界面可查看），预留至少 20GB 磁盘空间，提前准备有线网络（无线网络需后续额外配置）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;备份数据：安装过程会格式化磁盘，务必备份目标磁盘上的重要数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、开始安装（进入 Live 环境）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动并进入 Arch Live 环境&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将制作好的启动 U 盘插入目标设备，开机选择从 U 盘启动，进入 Arch Linux 启动菜单后，选择「Arch Linux install medium (x86_64, UEFI)」，等待加载完成后进入命令行 Live 环境（默认以 root 用户登录）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;验证 UEFI 启动模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行以下命令，若能列出目录内容，说明当前为 UEFI 模式，符合后续安装要求；若目录不存在，需切换为 UEFI 启动或调整为 BIOS 安装流程：&lt;/p&gt;
&lt;p&gt;ls /sys/firmware/efi/efivars&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置网络连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网络连接是安装的核心前提，优先使用有线网络（插上网线即可自动获取 IP），无线网络需手动配置：&lt;/p&gt;
&lt;p&gt;（1）验证网络连通性&lt;/p&gt;
&lt;p&gt;ping baidu.com -c 3  #  ping 3 次百度，成功返回则网络正常&lt;/p&gt;
&lt;p&gt;（2）无线网络配置（无有线时）&lt;/p&gt;
&lt;p&gt;iwctl  # 进入无线管理交互模式
device list  # 列出无线设备（通常为 wlan0）
station wlan0 scan  # 扫描周边 WiFi
station wlan0 get-networks  # 显示可用 WiFi 名称
station wlan0 connect &quot;WiFi名称&quot;  # 连接 WiFi，按提示输入密码
exit  # 退出 iwctl 模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;磁盘分区（UEFI + GPT 分区表）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 cfdisk 工具进行分区，以目标磁盘为 /dev/sda 为例（实际使用时需通过 lsblk 命令确认磁盘名称，避免误操作）：&lt;/p&gt;
&lt;p&gt;cfdisk /dev/sda  # 进入分区工具，选择 GPT 分区表&lt;/p&gt;
&lt;p&gt;推荐分区方案（适用于单系统）：&lt;/p&gt;
&lt;p&gt;分区路径&lt;/p&gt;
&lt;p&gt;分区大小&lt;/p&gt;
&lt;p&gt;分区类型&lt;/p&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;p&gt;/dev/sda1&lt;/p&gt;
&lt;p&gt;512M&lt;/p&gt;
&lt;p&gt;EFI System&lt;/p&gt;
&lt;p&gt;UEFI 引导分区&lt;/p&gt;
&lt;p&gt;/dev/sda2&lt;/p&gt;
&lt;p&gt;剩余全部空间&lt;/p&gt;
&lt;p&gt;Linux filesystem&lt;/p&gt;
&lt;p&gt;根分区（/）&lt;/p&gt;
&lt;p&gt;分区操作步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 cfdisk 界面，选择「Free space」，按 Enter 键选择「New」，输入分区大小（如 512M），创建 EFI 分区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选中新建的分区，按 Enter 键选择「Type」，找到「EFI System」并确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选中剩余的 Free space，重复步骤 1 创建根分区，分区类型默认「Linux filesystem」即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择「Write」，输入 yes 确认写入分区表，然后选择「Quit」退出 cfdisk。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;格式化分区&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分区完成后，对每个分区进行格式化（EFI 分区格式化为 FAT32，根分区格式化为 ext4）：&lt;/p&gt;
&lt;p&gt;mkfs.fat -F32 /dev/sda1  # 格式化 EFI 分区
mkfs.ext4 /dev/sda2      # 格式化根分区（会清除数据，确认无误再执行）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;挂载分区&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先挂载根分区到 /mnt，再创建 EFI 分区挂载目录并挂载：&lt;/p&gt;
&lt;p&gt;mount /dev/sda2 /mnt  # 挂载根分区
mkdir -p /mnt/boot/efi  # 创建 EFI 分区挂载目录
mount /dev/sda1 /mnt/boot/efi  # 挂载 EFI 分区&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装基础系统组件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 pacstrap 命令安装基础系统、内核、固件等核心组件：&lt;/p&gt;
&lt;p&gt;pacstrap /mnt base linux linux-firmware base-devel vim networkmanager&lt;/p&gt;
&lt;p&gt;组件说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;base：Arch Linux 基础系统组件，必装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;linux：Linux 内核，必装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;linux-firmware：硬件固件，解决多数网卡、显卡等硬件兼容性问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;base-devel：开发工具集，后续安装软件时可能需要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vim：文本编辑器，用于后续配置文件修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;networkmanager：网络管理工具，后续管理有线/无线网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;生成 fstab 文件（自动挂载分区）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;fstab 文件用于系统启动时自动挂载分区，执行以下命令生成并写入：&lt;/p&gt;
&lt;p&gt;genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/p&gt;
&lt;p&gt;生成后可通过以下命令验证，确保分区信息正确：&lt;/p&gt;
&lt;p&gt;cat /mnt/etc/fstab&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入新安装的系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过 arch-chroot 命令切换根目录到新安装的系统：&lt;/p&gt;
&lt;p&gt;arch-chroot /mnt&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统基础配置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）设置时区&lt;/p&gt;
&lt;p&gt;以上海时区为例，执行以下命令：&lt;/p&gt;
&lt;p&gt;ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  # 链接时区文件
hwclock --systohc  # 同步系统时间到硬件时钟&lt;/p&gt;
&lt;p&gt;（2）配置本地化&lt;/p&gt;
&lt;p&gt;编辑 locale.gen 文件，取消 en_US.UTF-8 和 zh_CN.UTF-8 的注释（去掉前面的 #）：&lt;/p&gt;
&lt;p&gt;vim /etc/locale.gen&lt;/p&gt;
&lt;p&gt;保存退出后，生成 locale：&lt;/p&gt;
&lt;p&gt;locale-gen&lt;/p&gt;
&lt;p&gt;设置默认 locale：&lt;/p&gt;
&lt;p&gt;echo &quot;LANG=en_US.UTF-8&quot; &amp;gt; /etc/locale.conf&lt;/p&gt;
&lt;p&gt;（3）设置主机名&lt;/p&gt;
&lt;p&gt;将「arch-pc」替换为你想要的主机名（如 my-arch）：&lt;/p&gt;
&lt;p&gt;echo &quot;arch-pc&quot; &amp;gt; /etc/hostname&lt;/p&gt;
&lt;p&gt;（4）设置 root 密码&lt;/p&gt;
&lt;p&gt;执行以下命令，按提示输入并确认密码（密码输入时不显示，正常现象）：&lt;/p&gt;
&lt;p&gt;passwd&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装并配置引导程序（GRUB）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装 GRUB 引导程序及 UEFI 相关组件：&lt;/p&gt;
&lt;p&gt;pacman -S grub efibootmgr&lt;/p&gt;
&lt;p&gt;将 GRUB 安装到 EFI 分区：&lt;/p&gt;
&lt;p&gt;grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB&lt;/p&gt;
&lt;p&gt;生成 GRUB 配置文件：&lt;/p&gt;
&lt;p&gt;grub-mkconfig -o /boot/grub/grub.cfg&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启用网络服务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置 NetworkManager 开机自启，确保系统启动后自动连接网络：&lt;/p&gt;
&lt;p&gt;systemctl enable NetworkManager
systemctl start NetworkManager  # 立即启动网络服务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成安装，重启系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;依次执行以下命令，退出 chroot 环境、卸载分区并重启：&lt;/p&gt;
&lt;p&gt;exit  # 退出 chroot 环境
umount -R /mnt  # 卸载所有挂载的分区
reboot  # 重启系统，重启前记得拔掉启动 U 盘&lt;/p&gt;
&lt;p&gt;三、后续优化（可选）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建普通用户：root 用户权限过高，日常使用建议创建普通用户（将「username」替换为你的用户名）：useradd -m username  # 创建用户并生成家目录
passwd username  # 为普通用户设置密码
usermod -aG wheel username  # 将用户添加到 wheel 组（获取 sudo 权限）
visudo  # 编辑 sudo 配置，取消 wheel 组注释（允许 wheel 组用户使用 sudo）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装桌面环境：若需要图形界面，可安装 GNOME、KDE 等桌面环境（以 GNOME 为例）：
pacman -S gnome gdm
systemctl enable gdm  # 启用 GDM 登录管理器，开机自动进入图形界面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装显卡驱动：根据显卡型号安装对应驱动（NVIDIA 显卡示例）：
pacman -S nvidia nvidia-utils&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更换国内镜像源：编辑 /etc/pacman.d/mirrorlist，将国内镜像源（如阿里云、清华大学）放在前面，提升软件下载速度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;四、常见问题排查&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网络连接失败：优先检查网线是否插好，无线连接需确认 WiFi 名称和密码正确；若扫描不到 WiFi，可能是缺少无线网卡固件，可重新进入 Live 环境，通过 pacstrap 安装对应的固件包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引导失败：检查 GRUB 安装步骤是否正确，可重新进入 Live 环境，挂载分区后重新生成 GRUB 配置文件（grub-mkconfig -o /boot/grub/grub.cfg）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统启动后无网络：确认 NetworkManager 服务已启用，可通过 systemctl status NetworkManager 查看服务状态，异常则执行 systemctl restart NetworkManager 重启服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区时误操作：若误删分区，停止所有操作，可尝试使用 testdisk 工具恢复分区表（需提前准备 testdisk 工具或包含该工具的 Live 镜像）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过以上步骤即可完成 Arch Linux 的基础安装，后续可根据个人需求安装软件、配置环境。若需更详细的优化教程，可关注后续博客更新。&lt;/p&gt;
</content:encoded></item><item><title>Simple Guides for Mizuki</title><link>https://lzwpluto.github.io/posts/guide/</link><guid isPermaLink="true">https://lzwpluto.github.io/posts/guide/</guid><description>How to use this blog template.</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;This blog template is built with &lt;a href=&quot;https://astro.build/&quot;&gt;Astro&lt;/a&gt;. For the things that are not mentioned in this guide, you may find the answers in the &lt;a href=&quot;https://docs.astro.build/&quot;&gt;Astro Docs&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Front-matter of Posts&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The title of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;published&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The date the post was published.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pinned&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Whether this post is pinned to the top of the post list.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;priority&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The priority of the pinned post. Smaller value means higher priority (0, 1, 2...).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A short description of the post. Displayed on index page.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The cover image path of the post.&amp;lt;br/&amp;gt;1. Start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;: Use web image&amp;lt;br/&amp;gt;2. Start with &lt;code&gt;/&lt;/code&gt;: For image in &lt;code&gt;public&lt;/code&gt; dir&amp;lt;br/&amp;gt;3. With none of the prefixes: Relative to the markdown file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The tags of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The category of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;licenseName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The license name for the post content.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;author&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The author of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sourceLink&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The source link or reference for the post content.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If this post is still a draft, which won&apos;t be displayed.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Where to Place the Post Files&lt;/h2&gt;
&lt;p&gt;Your post files should be placed in &lt;code&gt;src/content/posts/&lt;/code&gt; directory. You can also create sub-directories to better organize your posts and assets.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item></channel></rss>